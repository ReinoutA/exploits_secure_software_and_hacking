# <span style="color: yellow;">Scenario 6</span>

## Context
***
- server_data is <span style="color: red;">not accessible</span>
- stack canaries are <span style="color: green;">enabled</span>
- DEP is <span style="color: green;">enabled</span>
- ASLR is <span style="color: green;">enabled</span>

## Exploit overview
***
This exploit is unfinished. 


## Challenges & Decisions
***
### Canary Leaking
We can leak the canaries but we haven't been able to get them back to the victim machine. We can only read the first 0x23000 of the leaked data (```build_200_response_read```), and we need to read at least 0x500000 bytes to get to the canary.

```shell
ssize_t rax_6 = read(rax_1, &arg2[len], (0x23000 - len));
```

### .dynamic and function interposition
The intended way is probably using function interposition. Scenario 4 and scenario 6 contain two extra .dynamic entries:

DT_RELACOUNT: 0x6

All Elf32_Rela (or Elf64_Rela) R_*_RELATIVE relocations have been placed into a single block and this entry specifies the number of entries in that block. This permits the runtime linker to streamline the processing of RELATIVE relocations.

DT_FLAGS_1: 0x8000000 

DF_BIND_NOW: If set in a shared object or executable, this flag instructs the dynamic linker to process all relocations for the object containing this entry before transferring control to the program. The presence of this entry takes precedence over a directive to use lazy binding for this object when specified through the environment or via dlopen(BA_LIB).

# Possible attack scenario
We can check with ldd which dll's the server_sc6 binary uses.
```shell
osboxes@osboxes:~/secure-software-and-hacking-assignment/server$ ldd server_sc6
        linux-vdso.so.1 (0x00007ffcafee6000)
        libcrypto.so.1.1 => /lib/x86_64-linux-gnu/libcrypto.so.1.1 (0x00007fbfd10e1000)
        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fbfd10bf000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fbfd0eeb000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fbfd0ee5000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fbfd13e3000)
```

For scenario six we see that there are six of these used. One of these files is external. Normally the dll should be loaded into memory when the executable is executed. Our hypothesis for an attack scenario is overwriting one of the above files, replacing one of the functions in the file with our own and hijacking the control flow, doing the same steps as in scenario 3 of:
1. Creating the keylog file
2. Posting the binary to the keylog file
3. Executing the keylog file